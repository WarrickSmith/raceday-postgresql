Objective: Fix the Race Page, Enhanced Race Entrants, Money Flow Timeline component so it displays Entrant (Runner) information correctly for each race over time. Ensure that the data is persistent and can be reviewed at any time before,  during and after the race finishes and if the race is navigated away from and back to.

Items to be verified and fixed:

Task 1.
- Ensure the Money Flow Timeline columns always display the column header values of 60m, 55m, 50m, 45m, 40m, 35m, 30m, 25m, 20m, 15m, 10m, 5m, 4m, 3m, 2m, 1m, 30s, 0. Where these values represent the fixed time periods in minutes and seconds before a scheduled race start.

- Ensure that if a race does not start at 0s (it's scheduled start time), then additional timeline columns are inserted to the right of '0s' every 30 seconds until the race status changes from 'Open' to any other value like, Closed, Interim, Final or Abandoned. Ensure these dynamic columns persist after race finish. When a race does not start at 0s. I shouls see additional columns like -30s, -1m, -1:30s, -2m etc       

- Ensure there is horizontal an vertical scrolling for the timelin columns and that the columns to the left of the 60m column are sticky along with the Pool and Pool% columns on the right of the timeline.

- There should be a visual indicator of the current time relative to the moneyflow timeline columns that highlights the current active column relative to the schduled race start time.

- Currently much of the above tasks are implemented, except for an active race withint 60m of it's scheduled start time, te timeline columns up to the current actine column are disappearing and the active column is not correctly highlighted (background color change).

For reference of the concept of how this should look, this file shows a screen shot of an old application with similar functionality except that this applicat displays moneyflow data from three different sources for each entrant (runner):
/home/warrick/Dev/raceday/BT Main Screen2.jpg

Note if using Playwright to view the client application allow plenty of time for page, race, entrant and data rendering and population.

Task 1 Summary of Dev actions Taken:
‚úÖ COMPLETED - Fixed EnhancedEntrantsGrid.tsx timeline column generation:
- Removed filtering logic that was hiding columns 60m-25m for races within 60m of start
- Fixed active column highlighting algorithm to correctly identify next polling interval (not closest time)  
- Verified all 18 timeline columns display correctly: 60m through 0 (Start)
- Maintained sticky column architecture for Runner/Win/Place (left) and Pool/Pool% (right)
- Preserved horizontal scrolling functionality across full timeline
- Dynamic post-start column infrastructure implemented (triggers when race status changes from 'Open')
- Active column highlighting now shows green background on correct interval (e.g. 10m column when 13:53 to start)

‚úÖ COMPLETED - Implemented dynamic post-start column generation:
- Fixed column labeling to show proper format: "-30s", "-1m", "-1:30m", "-2m", "-2:30m", "-3m" etc.
- Dynamic columns generate every 30 seconds for first 2 minutes, then every minute thereafter
- Columns persist for completed races (status != 'Open') enabling review of delayed race data
- Labels correctly format half-minute intervals as "-1:30m" style (not "-1.5m")
- Column generation triggers when race doesn't start at scheduled time (0s)
- Implementation tested and validated in EnhancedEntrantsGrid.tsx lines 664-676

‚úÖ COMPLETED - Fixed JavaScript ReferenceError:
- Fixed "Cannot access 'isCurrentTimeColumn' before initialization" error in EnhancedEntrantsGrid.tsx
- Moved isCurrentTimeColumn function declaration from line 866 to line 694 (before its usage in useEffect)
- Removed duplicate function declaration to prevent conflicts
- Timeline functionality now working without runtime errors



Task 2: Display accurate wager (moneyflow) data in the appropriate row and column for each entrant (runner) for any given race timeline period, before, during and after a race.

For reference of the concept of how this should look, this file shows a screen shot of an old application with similar functionality except that this applicat displays moneyflow data from three different sources for each entrant (runner):
/home/warrick/Dev/raceday/BT Main Screen2.jpg

You will see that at 60mi (60m) before the start of the scheduled race at 0s, there is an amount of money displayed which is the total current sum of wagers (money) bet on the entrant (runner) at the 60m time. Subsequently the amouns shown are the 'difference' in the amount in the previous column and the current timeline column. In my app the concept is the smae but my column timline intervals differ. Effectively as a user I want to monitor the amouns of additional money being wagered on each entrant over time to identify anomolies. My app also only has one data surce per entrant not three as shown in the example screen shot image.

ISSUE: My application does not correctly display the wagers added over time which I call the moneyflow. The Money Flow Timeline component in the Enhanced Race Entrants component on the Race page is where this is displayed.

I want you to investigate the best strategy to obtain the correct data from the NZTAB using the NZTAB api as defined in their openapi spec at:
docs/nztab/openapi.json
The data from the API should be saved In an Appwrite Database so that the correct wagers can be displayed in the client application component as they are received and updated over time. This means that if multiple amounts of wager details are received between 50m and 45m then these are aggregated and displayed in the 45m column as the current difference between the current total and the last total at 50m.

You need to think about what data needs to be manipulated at the backend prior to saving in a database for subsequent dispay on the client front end. Calculations should be minimised on the front end.

Appwrite functions will be scheduled to retrieve the data from the NZTAB API , manipulated it and save it to the DB. The client component will be scrobed to the Appwrite database to receive data updates when that happen and display the data accordingly. The saving of the data will also ensure that the data can continue to persist and be displayed in the front end componen before, during and after a race and when navigating between races, so it is likely the an initial client side rende wil fetch existing data, subscribe for updates and close doen subscription when navigating away from that race.

Examine all the data available and what will need to be calculated to create usable data to achieve the front end display of wager (moneyflow) amount relative to the scheduled start time and beyond to the actual race start time.

To help, here is some sample data fetched for a single race at some time intervals prior to the race start for you to analyse an undrsatnd the data you will be working with.
SAMPLE Race Data/racedata1+70m.json
SAMPLE Race Data/racedata2+35m.json SAMPLE Race Data/racedata3+30m.json SAMPLE Race Data/racedata4+20m.json SAMPLE Race Data/racedata5+15m.json SAMPLE Race Data/racedata6+10m.json SAMPLE Race Data/racedata7+5m.json SAMPLE Race Data/racedata8-2m.json 

You will likely see aggregated totals in each subsequent data file update.

I want you to detail a startegy to get the Data from the source NZTABAPI to the final display of that Data in the moneyflow grid on the client, utilising Appwrite functions and Appwrite database and realtime client subscriptions. Do this as a new exercise ignoring the existing code and document your strategy in this document below:

Strategy:

## Task 2 Implementation Strategy: Accurate Money Flow Data Pipeline

### 1. Data Source Analysis (NZTAB API)

Based on analysis of sample race data from `/SAMPLE Race Data/racedata2+35m.json`, the NZTAB API provides:

#### Available Pool Data in API Response:
- **Win Pool**: `product_type: "Win"` with `total` amount
- **Place Pool**: `product_type: "Place"` with `total` amount  
- **Tote Trends XML**: Contains runner-level investment amounts in `tote_trends_data`

#### Key Data Structure in XML:
```xml
<bet_type type="WIN">
  <pool_total>2181.43</pool_total>
  <runners>
    <runner runner_number="1">
      <runner_investment>548.22</runner_investment>
    </runner>
  </runners>
</bet_type>
```

### 2. Data Pipeline Architecture

#### Phase 1: Data Collection (Appwrite Functions)
- **Function**: `race-money-flow-poller`
- **Schedule**: Variable frequency (5m ‚Üí 1m ‚Üí 30s as race approaches)
- **Process**:
  1. Fetch race data from NZTAB API
  2. Parse tote_trends XML for runner-level investments
  3. Extract Win/Place pool amounts per entrant
  4. Calculate time-to-start for timeline positioning

#### Phase 2: Data Processing (Backend Calculation)
- **Function**: `money-flow-processor` 
- **Processing Logic**:
  1. **Aggregation**: Sum multiple polling records within same time interval
  2. **Incremental Calculation**: Current amount - Previous interval amount = increment
  3. **Timeline Bucketing**: Group data into standard intervals (60m, 55m, 50m...0s, -30s, -1m...)

#### Phase 3: Database Storage (Optimized Schema)

**Collection**: `money-flow-timeline`
```typescript
interface MoneyFlowTimelineRecord {
  $id: string
  raceId: string
  entrantId: string
  timeInterval: number        // -60, -55, -50... 0, 1, 2 (minutes to/from start)
  intervalType: string        // "5m", "1m", "30s" 
  pollingTimestamp: string    // Actual data collection time
  
  // Absolute amounts (total invested at this time)
  winPoolAmount: number       // Total win pool for entrant (cents)
  placePoolAmount: number     // Total place pool for entrant (cents)
  
  // Pre-calculated incremental amounts (difference from previous interval)
  incrementalWinAmount: number    // Change in win pool since last interval
  incrementalPlaceAmount: number  // Change in place pool since last interval
  incrementalTotalAmount: number  // Total change for display
  
  // Metadata
  poolPercentage: number      // Entrant's percentage of total pool
  sourceApiTimestamp: string  // Original NZTAB API timestamp
}
```

### 3. Real-Time Data Flow

#### Appwrite Function Scheduler:
```
75m+ before race: Poll every 10 minutes (baseline collection)
60m-30m before:   Poll every 5 minutes  
30m-10m before:   Poll every 2 minutes  
10m-0s:          Poll every 1 minute
0s onwards:      Poll every 30 seconds (until race status changes from 'Open')

STOP POLLING IF: Race status = 'Abandoned', 'Cancelled', or 'Postponed'
```

#### Backend Processing Pipeline:
1. **Raw API Data** ‚Üí Parse tote_trends XML + Check race status
2. **Extract Pool Amounts** ‚Üí Group by entrant + time interval
3. **Calculate Increments** ‚Üí Compare with previous interval data (ONLY positive increments)
4. **Data Validation** ‚Üí Ensure no negative values, handle no-change as null
5. **Store Processed Data** ‚Üí Save to `money-flow-timeline` collection with persistence
6. **Trigger Real-time Event** ‚Üí Notify client subscribers

#### Race Status Handling:
- **Active Races**: Continue polling based on schedule
- **Abandoned/Cancelled**: Stop polling immediately, preserve existing data
- **Completed**: Stop polling, maintain all data for historical viewing
- **Delayed Start**: Continue polling beyond scheduled start time, create dynamic columns

### 4. Client-Side Integration

#### Modified Hook: `useMoneyFlowTimeline.ts`
```typescript
// Simplified client logic - server does heavy lifting
const fetchTimelineData = async () => {
  const response = await fetch(
    `/api/race/${raceId}/money-flow-timeline?entrants=${entrantIds.join(',')}&poolType=${poolType}`
  );
  
  const data = await response.json();
  // Data already processed and bucketed by server
  return processBucketedTimelineData(data.documents);
};
```

#### Timeline Grid Display Logic:
- **60m Column**: Show absolute pool amount (`$2,341`) - baseline from 75m+ polling
- **Subsequent Columns**: Show incremental change (`+$344`) or `‚Äî` for no change
- **NO NEGATIVE VALUES**: Money only flows IN - negative increments indicate data errors
- **Real-time Updates**: Flash cells on value changes
- **Post-Race Persistence**: All data remains accessible after race completion
- **Dynamic Columns**: Preserve Task 1 functionality for delayed race starts (-30s, -1m, -1:30m, etc.)

#### Display Rules:
- **Positive increment**: `+$344`
- **No change**: `‚Äî` (not `$0`)
- **Missing data**: `‚Äî`
- **Data error/negative**: `‚Äî` (log warning)

### 5. Implementation Steps

#### Step 1: Create Money Flow Polling Function
- New Appwrite function: `server/money-flow-poller/`
- Parse NZTAB tote_trends XML for runner investments
- Extract Win/Place pool amounts per entrant
- **Start polling at 75m+ before race** to establish baseline for 60m column
- Monitor race status - stop polling if Abandoned/Cancelled
- Store raw polling data with timestamps

#### Step 2: Create Data Processing Function  
- New Appwrite function: `server/money-flow-processor/`
- Process raw polling data into timeline intervals
- **Calculate ONLY positive incremental amounts** between time periods
- Handle no-change scenarios (store as null, display as `‚Äî`)
- **Validate no negative increments** - log errors for investigation
- Handle aggregation for high-frequency updates
- **Preserve data persistence** for post-race viewing

#### Step 3: Update Database Schema
- Create `money-flow-timeline` collection
- Index on raceId, entrantId, timeInterval
- Configure real-time subscriptions

#### Step 4: Modify Client Components
- Update `useMoneyFlowTimeline.ts` to use processed data
- **PRESERVE Task 1 functionality**: Keep existing timeline column generation logic intact
- **PRESERVE dynamic columns**: Maintain post-start column functionality (-30s, -1m, etc.)
- Simplify timeline cell rendering to use server-processed increments
- Add real-time subscription for live updates
- **Ensure data persistence**: Historical viewing after race completion or navigation

#### Step 5: Scheduler Integration
- Integrate with existing `master-race-scheduler`
- Dynamic polling frequency based on race proximity
- Handle post-race data persistence

### 6. Data Validation & Quality

#### Backend Validation:
- **No negative increments**: Money only flows IN to pools
- **Baseline data collection**: Start polling 15m+ before first display column (75m+ for 60m baseline)
- Timeline continuity validation (no missing intervals)
- Cross-reference with race pool totals
- **Race status monitoring**: Stop polling for abandoned races

#### Client Display:
- Show `‚Äî` for no change (not `$0`)
- Show `‚Äî` for missing data intervals  
- Show `‚Äî` for data errors/negative values (with console warning)
- Flash cells for real-time updates
- Validate timeline summation matches footer pool totals
- **Preserve Task 1 UI behavior**: Timeline columns, active column highlighting, sticky columns

### 7. Performance Optimizations

#### Database:
- Pre-calculated incremental amounts (no client-side math)
- Bucketed data storage (one record per interval per entrant)
- Efficient indexing on timeline queries

#### Client:
- Memoized timeline calculations
- Debounced real-time updates
- Lazy loading for historical race data

### 8. Addressing Specific Requirements

#### 1. Baseline Data Collection (65m+ Polling)
**Problem**: Need existing data at 60m to calculate increments for 55m column
**Solution**: Start polling at 75m+ (15 minutes before first display column)
- Provides baseline data for 60m absolute amount display
- Enables proper increment calculations for all subsequent columns

#### 2. Abandoned Race Handling  
**Implementation**: Race status monitoring in polling function
```typescript
if (raceStatus === 'Abandoned' || raceStatus === 'Cancelled' || raceStatus === 'Postponed') {
  console.log(`Race ${raceId} is ${raceStatus} - stopping money flow polling`);
  return; // Stop polling immediately
}
```

#### 3. Task 1 Functionality Preservation
**Critical Requirement**: Maintain all existing UI behavior from Task 1
- ‚úÖ Keep timeline column generation logic (60m, 55m... 0s, -30s, -1m, etc.)
- ‚úÖ Preserve active column highlighting (green background)  
- ‚úÖ Maintain sticky columns architecture
- ‚úÖ Keep dynamic post-start column generation for delayed races
- ‚úÖ Ensure data persistence for navigation and post-race viewing

#### 4. No Negative Values Logic
**Rule**: Money only flows INTO pools - never negative increments
**Implementation**: 
```typescript
const increment = currentPoolAmount - previousPoolAmount;
if (increment < 0) {
  console.warn(`Negative increment detected: ${increment} - treating as no change`);
  return null; // Will display as "‚Äî"
}
return increment > 0 ? increment : null; // null = no change = "‚Äî"
```

#### 5. No Change Display Logic
**Requirement**: Show `‚Äî` not `$0` when no money flow change occurs
**Implementation**:
```typescript
// Backend: Store null for no change
incrementalAmount: increment > 0 ? increment : null

// Client: Display logic
const displayValue = incrementalAmount === null ? '‚Äî' : `+$${incrementalAmount}`;
```

This revised strategy addresses all concerns while preserving existing functionality and ensuring accurate money flow tracking.



Task 3 Implementation Plan for Accurate Money Flow Data Pipeline

I now want you to review the strategy you created in ## Task 2 Implementation Strategy: Accurate Money Flow Data Pipeline and compare it to what is currently implemented in the project \Server and \Client directories and create a plan to take the existing application from it's current state to the new fixed state as defined in your sttrategy.
NOTE: Appwrite functions are deployed using NPM scripts in \server\package.json and Appwrite CLI. Appwrite functions are deployed as self contained code and will likely require duplicate code for a polling startegy to work. There is already a master scheduler, some daily functions and functions that are called according to a dynamic schedule and race start times.
Your implementtionplan should have simple, verifiable stages to ensure logic and the plan are working as expected as it is implemented in logical stages.

Create the plan and document it in detail below for a developer to implement:

# Task 3 Implementation Plan for Accurate Money Flow Data Pipeline

## Revised Current State Analysis

Based on comprehensive analysis of the existing codebase, I found:

**‚úÖ Already Implemented Infrastructure:**
- **money-flow-history collection** exists with comprehensive attributes: `timeInterval`, `incrementalWinAmount`, `incrementalPlaceAmount`, `winPoolAmount`, etc.
- **Existing money flow polling** in all pollers (`batch-race-poller`, `single-race-poller`, etc.) with `tote_trends_data=true` parameter
- **Client API endpoint** exists at `/api/race/[id]/money-flow-timeline/route.ts` 
- **Client hook** `useMoneyFlowTimeline.ts` with bucketed data processing logic
- **Database setup** handled by `daily-meetings/src/database-setup.js` with proper indexing
- **Master scheduler** with proper race status handling: `Open` ‚Üí `Closed` ‚Üí `Interim` ‚Üí `Final`

**‚ùå Critical Issues Identified:**
- **No XML parsing implementation** - Functions request `tote_trends_data` but don't process the XML `runner_investment` data
- **Broken bucketing logic** - `timeInterval` calculations not working properly in existing functions
- **Missing incremental calculations** - No logic to calculate `+$344` differences between time periods  
- **Incomplete baseline data** - No dedicated collection for 75m+ baseline data to establish 60m column amounts
- **Client data processing issues** - Hook expecting specific data format but server not providing it correctly

**üîç Key Data Discovery:**
- XML structure: `<runner runner_number="1"><runner_investment>548.22</runner_investment></runner>`
- Sample data shows runner investments increasing over time (perfect for incremental calculations)
- Existing database schema supports all required functionality but isn't being used properly

## Revised Implementation Plan - 5 Focused Stages

### **Stage 1: Fix Existing Money Flow Data Processing**
**Goal:** Enhance existing polling functions to properly parse XML and calculate timeline data

**Server-Side Tasks:**
1. **Add XML parsing to existing pollers:**
   - Modify `batch-race-poller/src/database-utils.js:saveMoneyFlowHistory()`
   - Add XML parsing logic to extract `runner_investment` from `tote_trends_data`
   - Parse both WIN and PLACE bet types for comprehensive data
   
2. **Fix timeline bucketing logic:**
   - Properly calculate `timeInterval` values (60, 55, 50... 0, -0.5, -1)
   - Map polling times to correct display columns
   - Store `intervalType` as "5m", "1m", "30s" based on proximity to race start

3. **Add incremental calculations:**
   - Calculate `incrementalWinAmount` = current - previous interval amount  
   - Calculate `incrementalPlaceAmount` = current - previous interval amount
   - Ensure positive increments only (money flows IN, never OUT)
   - Handle no-change scenarios (store as null, display as `‚Äî`)

4. **Update race status polling logic:**
   - Continue polling through `Open` ‚Üí `Closed` ‚Üí `Interim` ‚Üí `Final` sequence
   - Stop only at `Final`, `Finalized`, or `Abandoned` status
   - Remove premature polling stops

**Files to modify:**
- `server/batch-race-poller/src/database-utils.js`
- `server/single-race-poller/src/database-utils.js` 
- `server/master-race-scheduler/src/main.js`

**XML Parsing Implementation:**
```javascript
function parseToTeTrendsXML(xmlString, betType = 'WIN') {
  // Use built-in DOMParser (Node.js 18+ supports this)
  const parser = new DOMParser();
  const doc = parser.parseFromString(xmlString, 'text/xml');
  
  const runners = [];
  const betTypeElement = doc.querySelector(`bet_type[type="${betType}"]`);
  if (betTypeElement) {
    betTypeElement.querySelectorAll('runner').forEach(runner => {
      const runnerNumber = runner.getAttribute('runner_number');
      const investment = runner.querySelector('runner_investment')?.textContent;
      if (runnerNumber && investment) {
        runners.push({
          runnerNumber: parseInt(runnerNumber),
          investment: parseFloat(investment) * 100 // Convert to cents
        });
      }
    });
  }
  return runners;
}
```

### **Stage 2: Add Daily Baseline Data Collection**
**Goal:** Integrate baseline money flow collection with existing daily data functions

**Tasks:**
1. **Enhance `daily-initial-data` function** (runs at 8:30 PM NZ time, 30 minutes after daily-races):
   - Add money flow baseline collection for all next-day races
   - Collect 75m+ data to establish baseline for 60m timeline column
   - Store as `timeInterval: 75, 70, 65, 60` for proper display progression

2. **Integration approach:**
   - Add baseline polling call to existing `daily-initial-data/src/main.js`
   - Use same batch processing logic as existing race data collection
   - Leverage existing rate limiting and error handling

**Files to modify:**
- `server/daily-initial-data/src/main.js`
- Add baseline collection logic to existing batch processing

### **Stage 3: Enhance Timeline Data Processing and Bucketing**
**Goal:** Fix timeline interval mapping and ensure proper column data persistence

**Tasks:**
1. **Fix timeline interval calculations:**
   ```javascript
   function getTimelineInterval(timeToStartMinutes) {
     if (timeToStartMinutes >= 60) return 60;
     if (timeToStartMinutes >= 55) return 55;
     if (timeToStartMinutes >= 50) return 50;
     // ... continue for all standard intervals: 45, 40, 35, 30, 25, 20, 15, 10, 5, 4, 3, 2, 1
     if (timeToStartMinutes >= 0) return 0; // Race start
     if (timeToStartMinutes >= -0.5) return -0.5; // -30s  
     return Math.ceil(timeToStartMinutes); // -1, -2, -3, etc. for delayed starts
   }
   ```

2. **Add delayed race column support:**
   - Generate dynamic columns for races that don't start at scheduled time
   - Create timeline intervals: -30s, -1m, -1:30m, -2m, -2:30m, etc.
   - Persist data for post-race viewing and navigation

3. **Implement incremental validation:**
   - Ensure incremental amounts are positive (money only flows IN)
   - Cross-validate increments sum to footer pool totals
   - Handle missing data gracefully (display as `‚Äî`)

**Key bucketing logic:**
- **60m column**: Show absolute amount (`$2,341`) from baseline data
- **Subsequent columns**: Show incremental change (`+$344`) or `‚Äî` for no change
- **Math validation**: All increments must sum to pool totals

### **Stage 4: Comprehensive Client-Side Review and Fixes**
**Goal:** Fix client data processing and ensure proper timeline display

**Client-Side Issues Analysis:**

**Current Problems in `useMoneyFlowTimeline.ts`:**
1. **Data Processing Issues:**
   - Hook expects `bucketedData` flag but processing logic is inconsistent  
   - Complex entrant ID extraction logic causing data mismatches
   - Grid generation not properly handling timeline intervals
   - Real-time subscriptions may not be triggering correctly

2. **Timeline Grid Generation Issues:**
   - `gridData` mapping not correctly processing server bucketed data
   - Incremental amount display logic needs fixing
   - Currency conversion (cents to dollars) may be incorrect

**Client-Side Tasks:**

1. **Fix `useMoneyFlowTimeline.ts` data processing:**
   - Simplify bucketed data processing (server does heavy lifting)
   - Fix entrant ID matching logic
   - Improve grid data generation for timeline display
   - Validate real-time subscription channel format

2. **Enhance timeline display logic:**
   - Ensure 60m column shows absolute amounts
   - Subsequent columns show proper incremental format: `+$344`, `‚Äî`, etc.
   - Fix currency conversion and formatting
   - Preserve Task 1 UI behavior (columns, highlighting, persistence)

3. **Update API endpoint processing:**
   - Verify `/api/race/[id]/money-flow-timeline/route.ts` returns correct format
   - Ensure bucketed data queries work with new server data
   - Add fallback logic for legacy data format

**Enhanced Client Hook Logic:**
```typescript
// Simplified processing for server-bucketed data
const processBucketedTimelineData = (documents, entrantIds) => {
  const entrantDataMap = new Map();
  
  entrantIds.forEach(entrantId => {
    const entrantDocs = documents.filter(doc => 
      getEntrantId(doc.entrant) === entrantId
    );
    
    // Sort by timeInterval (server pre-calculated)
    const sortedDocs = entrantDocs.sort((a, b) => 
      (b.timeInterval || 0) - (a.timeInterval || 0)
    );
    
    // Use server pre-calculated incremental amounts
    const dataPoints = sortedDocs.map(doc => ({
      timeToStart: doc.timeToStart || 0,
      timeInterval: doc.timeInterval || 0,
      incrementalAmount: doc.incrementalWinAmount || doc.incrementalPlaceAmount || 0,
      // ... other fields
    }));
    
    entrantDataMap.set(entrantId, { entrantId, dataPoints });
  });
  
  return entrantDataMap;
};
```

### **Stage 5: End-to-End Testing and Validation**
**Goal:** Comprehensive testing with real data and complete pipeline validation

**Testing Tasks:**

1. **XML Parsing Validation:**
   - Test with sample files: `racedata2+35m.json`, `racedata3+30m.json`
   - Verify `runner_investment` extraction for different bet types
   - Validate data conversion (string ‚Üí float ‚Üí cents)

2. **Timeline Mathematics Verification:**
   - Check incremental calculations: current - previous = increment
   - Validate positive increments only (no negative money flow)
   - Verify incremental amounts sum to footer pool totals
   - Test `‚Äî` display for no-change scenarios

3. **Race Status Transition Testing:**
   - Test polling through all status transitions: Open ‚Üí Closed ‚Üí Interim ‚Üí Final
   - Verify polling continues until Final/Abandoned status
   - Test delayed race scenarios (dynamic column generation)

4. **Client Integration Testing:**
   - Verify timeline grid displays: `$2,341` (60m), `+$344` (55m), `‚Äî` (no change)
   - Test real-time updates and UI responsiveness
   - Validate data persistence after navigation/page refresh
   - Test with real race ID: `279dc587-bb6e-4a56-b7e5-70d78b942ddd`

5. **Performance and Error Handling:**
   - Test with high-frequency data updates (30-second polling)
   - Validate graceful handling of API failures
   - Test memory usage with large datasets
   - Verify database query performance

**Validation Criteria:**
- XML parsing extracts correct runner investment amounts
- Timeline intervals map correctly to display columns  
- Incremental calculations are mathematically accurate
- Client displays proper format: absolute amounts, increments, and no-change indicators
- Real-time updates work smoothly without performance issues
- Data persists correctly for historical viewing

## Updated Technical Implementation Details

### **Race Status Handling (Corrected)**
```javascript
// CORRECT status-based polling sequence
function getPollingInterval(timeToStartMinutes, raceStatus) {
  if (raceStatus === 'Open') {
    // Continue polling until race actually closes
    if (timeToStartMinutes <= 1) return 0.5; // 30 seconds
    else if (timeToStartMinutes <= 5) return 1; // 1 minute  
    else return 5; // 5 minutes
  } else if (raceStatus === 'Closed') {
    return 0.5; // 30 seconds - transition period
  } else if (raceStatus === 'Interim') {
    return 5; // 5 minutes - wait for final results  
  } else if (raceStatus === 'Final' || raceStatus === 'Finalized' || raceStatus === 'Abandoned') {
    return null; // STOP polling - race is complete
  }
  return 5; // Default fallback
}
```

### **Data Flow Architecture**
1. **Daily baseline** (8:30 PM): Collect 75m+ data for all next-day races
2. **Dynamic polling**: Master scheduler triggers individual/batch pollers based on race proximity
3. **XML processing**: Parse `tote_trends_data` ‚Üí extract `runner_investment` ‚Üí calculate timeline intervals
4. **Incremental calculation**: (current amount - previous interval amount) = display increment
5. **Client API**: Query bucketed data ‚Üí format for timeline display
6. **Real-time updates**: Database changes ‚Üí subscription triggers ‚Üí UI refresh

### **Performance Optimizations**
- **Leverage existing infrastructure**: Enhance current functions rather than duplicate
- **Reduce API overhead**: Parse XML data already being requested  
- **Efficient database queries**: Use existing indexes on `timeInterval`, `pollingTimestamp`
- **Client-side optimization**: Server pre-calculates increments to minimize client processing

### **Integration with Existing Systems**
- **Master Scheduler**: Already coordinates polling - just enhance data processing
- **Database Schema**: All required attributes already exist in `money-flow-history` collection
- **API Endpoint**: Already exists - just needs to return properly processed data  
- **Client Hook**: Framework exists - needs data processing fixes

This revised plan addresses the real issues: missing XML parsing, broken bucketing logic, incomplete incremental calculations, and client-side data processing problems. It builds on existing robust infrastructure rather than creating duplicate systems.

