<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.9</storyId>
    <title>Dynamic Scheduler with Time-Based Intervals</title>
    <status>Ready</status>
    <generatedAt>2025-10-14</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/warrick/Dev/raceday-postgresql/docs/stories/story-2.9.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>scheduler that adjusts polling frequency based on time-to-start</iWant>
    <soThat>I can poll at 15s intervals during critical 5-minute window</soThat>
    <tasks>
      - Task 1: Implement interval calculation logic (AC: 2, 3)
      - Task 2: Implement race query and scheduling logic (AC: 1, 4)
      - Task 3: Implement interval cleanup (AC: 5)
      - Task 4: Implement continuous re-evaluation loop (AC: 6)
      - Task 5: Add structured logging (AC: 7)
      - Task 6: Add unit tests for scheduler logic (AC: All)
      - Task 7: Add integration tests for end-to-end scheduling (AC: All)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Scheduler queries database for upcoming races
    2. For each race, calculates time-to-start (start_time - current time)
    3. Determines polling interval based on time-to-start: ≤5 minutes: 15 seconds, 5-15 minutes: 30 seconds, >15 minutes: 60 seconds
    4. Schedules race processing using setInterval per race
    5. Clears interval when race completes or is abandoned
    6. Scheduler runs continuously, re-evaluating intervals every minute
    7. Logging for: interval changes, race scheduling, race completion
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/tech-spec-epic-2.md" title="Epic 2 Technical Specification" section="Scheduler Module" relevance="Defines scheduler architecture, dynamic polling intervals, and integration with race processor">
        Technical specification for Epic 2 High-Performance Data Pipeline. Section on Scheduler (lines 41-42) describes dynamic polling cadence (15s, 30s, 60s) based on time-to-start. Scheduler queries database for upcoming races and applies adaptive intervals to meet 15s batch window requirement.
      </doc>
      <doc path="docs/solution-architecture.md" title="Solution Architecture" section="Dynamic Scheduler" relevance="High-level scheduler design and integration points">
        Solution architecture lines 338-344 describe dynamic scheduling patterns. Scheduler coordinates with race processor, maintains interval handles per race, and handles graceful cleanup when races complete.
      </doc>
      <doc path="docs/epic-stories-2025-10-05.md" title="Epic Stories Breakdown" section="Story 2.9" relevance="Original story definition and acceptance criteria">
        Story 2.9 requirements (lines 396-414) specify scheduler behavior: query database, calculate time-to-start, determine intervals (≤5min=15s, 5-15min=30s, >15min=60s), use setInterval per race, clear on completion, re-evaluate every minute, structured logging.
      </doc>
      <doc path="docs/PRD-raceday-postgresql-2025-10-05.md" title="Product Requirements Document" section="Performance Requirements" relevance="Performance targets and polling frequency requirements">
        PRD defines performance targets: 5 races in <15s, single race in <2s. Scheduler must poll frequently enough during critical 5-minute window to capture money flow changes without overloading system.
      </doc>
      <doc path="docs/CODING-STANDARDS.md" title="Coding Standards" section="TypeScript Standards" relevance="Code quality standards for scheduler implementation">
        TypeScript strict mode, no 'any' types, explicit return types, JSDoc comments for public APIs, consistent naming conventions (camelCase for functions, PascalCase for types).
      </doc>
    </docs>
    <code>
      <artifact path="server/src/pipeline/race-processor.ts" kind="module" symbol="processRace" lines="301-598" relevance="Core function scheduler will call at each interval tick">
        Exported function processRace(raceId: string, options?: ProcessOptions): Promise&lt;ProcessResult&gt;. Returns timings (fetch_ms, transform_ms, write_ms, total_ms), rowCounts, and status. Scheduler will call this function at calculated intervals.
      </artifact>
      <artifact path="server/src/pipeline/race-processor.ts" kind="interface" symbol="ProcessResult" lines="63-75" relevance="Return type from processRace that scheduler should handle">
        ProcessResult interface contains raceId, status, success, timings, rowCounts, optional error with type/message/retryable fields. Scheduler should log these results and handle failures.
      </artifact>
      <artifact path="server/src/database/pool.ts" kind="module" symbol="pool" lines="18" relevance="Database connection pool for querying upcoming races">
        PostgreSQL pool exported from database/pool.ts. Scheduler will use pool.query() to fetch upcoming races from database. Pool configured with max=10 connections, respects environment variables.
      </artifact>
      <artifact path="server/src/shared/logger.ts" kind="module" symbol="logger" lines="4-13" relevance="Pino logger for structured JSON logging">
        Pino logger configured with ISO timestamps, environment context, and log level from env.LOG_LEVEL. Scheduler must use logger.info() for scheduling events, logger.warn() for interval changes, logger.error() for failures.
      </artifact>
    </code>
    <dependencies>
      <node>
        <package name="pg" version="^8.16.3">PostgreSQL client for database queries (fetch upcoming races)</package>
        <package name="pino" version="^9.5.0">Structured logging for scheduler events</package>
        <package name="typescript" version="^5.7.0">TypeScript compiler with strict mode</package>
        <package name="vitest" version="^2.0.0">Testing framework for unit and integration tests</package>
      </node>
      <builtin>
        <module name="setInterval / clearInterval">Node.js built-in timers for scheduling race polling at calculated intervals</module>
        <module name="performance.now()">High-resolution timing for measuring operation duration</module>
      </builtin>
    </dependencies>
  </artifacts>

  <constraints>
    - Scheduler MUST NOT create duplicate intervals for the same raceId (use Map&lt;raceId, Timer&gt; to track active intervals)
    - Database queries for upcoming races MUST use existing idx_races_start_time index (filter WHERE status IN ('open', 'upcoming') AND start_time &gt; NOW())
    - Interval calculation MUST follow exact thresholds: ≤5min=15s, 5-15min=30s, &gt;15min=60s (no other values allowed)
    - Scheduler MUST clear interval handles when races complete/abandon to prevent memory leaks
    - Re-evaluation loop MUST run every 60 seconds (not faster to avoid database load, not slower to miss transitions)
    - All logging MUST use Pino structured JSON format with raceId, timestamps, intervals, and context fields
    - Scheduler MUST integrate with existing race processor from Story 2.7 (processRace function)
    - Scheduler MUST NOT block the event loop (use async/await, avoid synchronous operations)
    - TypeScript strict mode MUST be maintained (no 'any' types, explicit return types)
    - Testing MUST include unit tests (calculatePollingInterval, race scheduling) and integration tests (database queries, end-to-end scheduling)
  </constraints>

  <interfaces>
    <interface name="processRace" kind="function" signature="processRace(raceId: string, options?: ProcessOptions): Promise&lt;ProcessResult&gt;" path="server/src/pipeline/race-processor.ts">
      Main race processing function from Story 2.7. Scheduler calls this at each interval tick. Returns ProcessResult with timings, rowCounts, and status. Exported from race-processor module.
    </interface>
    <interface name="pool.query" kind="function" signature="pool.query(sql: string, params?: any[]): Promise&lt;QueryResult&gt;" path="server/src/database/pool.ts">
      PostgreSQL query function. Scheduler uses this to query upcoming races from database. Returns query result with rows array.
    </interface>
    <interface name="logger.info" kind="function" signature="logger.info(obj: object, msg: string): void" path="server/src/shared/logger.ts">
      Pino structured logging. Scheduler uses logger.info() for scheduling events, logger.warn() for warnings, logger.error() for failures.
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing strategy uses Vitest for both unit and integration tests. Unit tests mock external dependencies (database, setInterval) and test pure logic in isolation. Integration tests use real PostgreSQL test database with seeded fixtures. All tests must pass before story approval. Coverage target: &gt;80% for scheduler module.
    </standards>
    <locations>
      - server/tests/unit/scheduler/ (unit tests for interval calculation, race scheduling logic)
      - server/tests/integration/scheduler/ (integration tests with real database, end-to-end scheduling)
    </locations>
    <ideas>
      - AC1: Unit test for calculatePollingInterval() with boundary values (300s, 301s, 900s, 901s, negative values)
      - AC2-3: Unit test for interval calculation logic returning correct milliseconds (15000, 30000, 60000)
      - AC4: Unit test for scheduleRace() storing interval handle in Map and calling processRace at correct interval
      - AC5: Unit test for unscheduleRace() clearing interval handle and removing from Map
      - AC6: Integration test seeding database with races at different time-to-start values, verifying scheduler applies correct intervals
      - AC7: Integration test verifying structured logs emitted for interval changes, race scheduling, race completion
      - Edge cases: Test race starting during re-evaluation, database connection failure, duplicate raceId scheduling
    </ideas>
  </tests>
</story-context>
